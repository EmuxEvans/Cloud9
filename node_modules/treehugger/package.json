{
  "name": "treehugger",
  "version": "0.0.1",
  "description": "treehugger is a Javascript library for program processing",
  "author": {
    "name": "ajax.org B.V.",
    "email": "info@ajax.org"
  },
  "contributors": [
    {
      "name": "Zef Hemel",
      "email": "zef@c9.io"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/ajaxorg/treehugger.git"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "readme": "treehugger.js\n=============\n\n`treehugger.js` is a Javascript library for program processing. It\nhas generic means to represent and manipulate (analyze, transform)\n[abstract syntax trees (ASTs)](http://en.wikipedia.org/wiki/Abstract_syntax_tree).\nIt consists of three parts:\n\n* A generic ASTs representation format, inspired by [ATerms](http://www.meta-environment.org/Meta-Environment/ATerms))\n  that can be used to represent programs written in any language (Java, Ruby, Javascript)  \n  `lib/treehugger/tree.js`\n* A set of generic traversals to query, manipulate and annotate these ASTs,\n  inspired by [Stratego/XT](http://strategoxt.org)  \n  `lib/treehugger/traverse.js`\n* A set of analyses for specific languages. Currently:\n  - Javascript: a ([UglifyJS](https://github.com/mishoo/UglifyJS)-based) parser\n    and analyses reconstructing the type structure and first attempts at type-inference.  \n    `lib/treehugger/js/*.js`\n\nThe project relies on [require.js](http://requirejs.org) for library loading.\n\nAST Representation\n------------------\n\nast.js uses a few simple data structures to represent ASTs and a textual representation\nthat makes it easy to debug and write these ASTs. The textual representation\nis best introduced by example.\n\nConsider a simple expresion language with expression as follows:\n\n    2 + 3 * 1\n\nA parser could turn this into the following AST:\n\n       Add\n      /   \\\n    Num   Mul\n     |   /   \\\n     2  Num  Num\n         |    |\n         3    1\n\nWhich is expressed using treehugger.js's textual representation as follows:\n\n    Add(Num(\"2\"), Mul(Num(\"3\"), Num(\"1\")))\n\nUsing the `treehugger.js` API this AST can be contructed as follows:\n\n    var tree = require('treehugger/tree');\n    var node = tree.cons(\"Add\", [tree.cons(\"Num\", [tree.string(\"2\")]),\n                                 tree.cons(\"Mul\", [tree.cons(\"Num\", [tree.string(\"3\")]),\n                                                   tree.cons(\"Num\", [tree.string(\"1\")])])]);\n\nOr, more simply:\n\n    var node = tree.parse('Add(Num(\"2\"), Mul(Num(\"3\"), Num(\"1\")))');\n\ntreehugger.js has three kinds of AST node types:\n\n* Strings (e.g. `\"2\"`, `\"myVariable\"`), usually representing identifiers or other\n  textual values.\n* Lists (e.g. `[\"a\", \"b\", None()]`)\n* Constructors (or simply: cons nodes) (e.g. `None()` or `Num(\"2\")`), used to represent\n  language constructs in the language, such as operators, loop constructs, etc.\n\n\nAST Analysis\n------------\n\nTreehugger.js is based on the concept of _generic traversals_. A generic traversal\ntraverses the tree in a particular order, for instance from top to bottom or from\nthe bottom up. At every node the traversal comes accross you can apply one or transformations.\nTranformations can either be AST _patterns_, _transformation functions_ or a combination of both.\n\nThe `treehugger/traverse.js` library adds a number of methods to AST nodes that make traversals simpler:\n\n* `collectTopDown` (traverses the tree top to bottom until finding a match, collecting all matches and returning them as a list)\n* `traverseTopDown` (traverses the tree top to bottom until finding a match)\n* (more are coming)\n\nA _transformation_ can be either:\n\n* A textual AST pattern\n* A textual AST pattern followed by a transformation function that is passed a binding object\n* A transformation function\n\nEach transform either _matches_ or _doesn't_ match. If a transformation function matches,\nit returns a non-falsy value (usually a new AST node), if it doesn't, it returns `false`.\nA simple example:\n\n    var node = tree.parse('Add(Num(\"2\"), Mul(Num(\"3\"), Num(\"1\")))');\n    node.collectTopDown(\"Num(_)\").debug();\n\nThis will traverse the AST and look for nodes that match the Num(_) _pattern_,\nwhere `_` (a wildcard) can be anything. The `collectTopDown` traversal traverses\nthe AST from top to bottom, and on the way collects all matches and returns them\nas an `ListNode`. The result of the `collectTopDown` call in this case will be:\n\n    [Num(\"2\"), Num(\"3\"), Num(\"1\")]\n\nThe `.debug()` call prints the result to the Javascript console (`console.log`).\n\nSo, what if we want to only return the numbers, not the `Num(...)` constructors?\nIf we follow a textual pattern by a function, we can transform the result:\n\n    var node = tree.parse('Add(Num(\"2\"), Mul(Num(\"3\"), Num(\"1\")))');\n    node.collectTopDown(\"Num(n)\", function(b) { return b.n; }).debug();\n\nInstead of using the placeholder `_`, we now used `n`. The function is passed a\n_bindings_ object whose `n` property will contain the value of the placeholder.\nSo, the following will be printed to the Javascript console:\n\n    [\"2\", \"3\", \"1\"]\n\nIf we want to match _either_ `Num` or `Mul` nodes we can add a pattern for that\nto the `collectTopDown` call:\n\n    var node = tree.parse('Add(Num(\"2\"), Mul(Num(\"3\"), Num(\"1\")))');\n    node.collectTopDown(\n      \"Num(n)\", function(b) {\n          return b.n;\n        },\n      \"Mul(op1, op2)\", function(b) {\n         return b.op1;\n      }\n    ).debug();\n\nThis will print:\n\n    [\"2\", Num(\"3\")]\n\nWhy is that? The AST is traversed top to bottom by `collectTopDown`. On its way, it will\ntry to match every node first against the `Num(n)` pattern. If that succeeds,\nthe function after it in the argument list is executed, if the function returns\na value other than `false`, the traversal stops at that branch and the result\nis added to the result list. If the `\"Num(n)\"` pattern did _not_ match, it is\nmatched against `\"Mul(op1, op2)\"`. Again, if this pattern matches, the function\nis executed etc. etc. The `collectTopDown` traversal will not traverse down to the\n`Num(\"3\")` and `Num(\"1\")` nodes, because the traversal stopped when matching the\n`Mul(..., ...)` node -- if, instead the tranformation function would have returned\n`false, the traversal would have proceeded down those nodes as well.\n\nLicense (MIT)\n-------------\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this\nsoftware and associated documentation files (the \"Software\"), to deal in the Software\nwithout restriction, including without limitation the rights to use, copy, modify,\nmerge, publish, distribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be included in all copies\nor substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nDemo\n----\n\nYou can see [treehugger.js in action in this simple demo](http://ajaxorg.github.com/treehugger/test.html).",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ajaxorg/treehugger/issues"
  },
  "_id": "treehugger@0.0.1",
  "dist": {
    "shasum": "d2fced1ffa539697b0ca2dae4e49362112930ad6"
  },
  "_from": "https://github.com/ajaxorg/treehugger/tarball/c6fb8e8c7ad7654577e1f843559fb91e925a3b79",
  "_resolved": "https://github.com/ajaxorg/treehugger/tarball/c6fb8e8c7ad7654577e1f843559fb91e925a3b79"
}
