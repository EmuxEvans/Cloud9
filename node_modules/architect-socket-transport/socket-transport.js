var EventEmitter = require('events').EventEmitter;
var msgpack = require('msgpack-js');

// Here input is a readable binary stream and output is a writable binary
// stream.
module.exports = socketTransport;
function socketTransport(input, output) {
    // If there is just one stream, assume it's duplex.
    if (arguments.length === 1) output = input;
    return new SocketTransport(input, output);
}
socketTransport.SocketTransport = SocketTransport;

// This implements a vfs transport over a duplex binary socket using msgpack
// and netstring encoding. The public API is simple. Send messages using
// .send(message).  Returns false on full buffer.  Emits "drain" when empty.
// Incoming messages emit "message" events.  If the connection gets
// disconnected, it will emit a "disconnect" event. Inherits from EventEmitter
SocketTransport.prototype = Object.create(EventEmitter.prototype, {constructor:{value:SocketTransport}});
function SocketTransport(input, output) {
    // Store the I/O streams
    this.input = input;
    this.output = output;

    // Bind event handlers
    this.onData = this.onData.bind(this);
    this.onDrain = this.onDrain.bind(this);
    this.disconnect = this.disconnect.bind(this);

    // Start the input parser
    this.reset();
    this.input.on('data', this.onData);

    // If either stream goes down we have a problem.
    this.input.on("close", this.disconnect);
    this.input.on("end", this.disconnect);
    this.output.on("close", this.disconnect);
    this.output.on("end", this.disconnect);

    // Forward drain events for proper backpressure support
    this.output.on("drain", this.onDrain);
}

SocketTransport.prototype.disconnect = function () {
    // Remove all added listeners to input and output
    this.input.removeListener('data', this.onData);
    this.input.removeListener("close", this.disconnect);
    this.input.removeListener("end", this.disconnect);
    this.output.removeListener("close", this.disconnect);
    this.output.removeListener("end", this.disconnect);
    this.output.removeListener("drain", this.onDrain);

    // Report the disconnect
    this.emit("disconnect", new Error("Disconnect detected"));
};

SocketTransport.prototype.onDrain = function () {
    this.emit("drain");
};

// Encode a message with proper length header.  Returns false if the kernel
// buffer is full. (same as node stream write)
SocketTransport.prototype.send = function send(message) {
    // Serialize the messsage.
    var frame = msgpack.encode(message);

    // Send a 4 byte length header before the frame.
    var header = new Buffer(4);
    header.writeUInt32BE(frame.length, 0);
    this.output.write(header);

    // Send the serialized message.
    return this.output.write(frame);
};


// Utility to reset the deframer state machine
SocketTransport.prototype.reset = function () {
    this.state = 0;
    this.length = 0;
    this.buffer = undefined;
    this.offset = undefined;
};

// Parse raw data chunks and emit "message" events
SocketTransport.prototype.onData = function (data) {
    for (var i = 0, l = data.length; i < l; i++) {
        switch (this.state) {
        case 0: this.length |= data[i] << 24; this.state = 1; break;
        case 1: this.length |= data[i] << 16; this.state = 2; break;
        case 2: this.length |= data[i] << 8; this.state = 3; break;
        case 3: this.length |= data[i]; this.state = 4;
            this.buffer = new Buffer(this.length);
            this.offset = 0;
            break;
        case 4:
            var len = l - i;
            var emit = false;
            if (this.offset + len >= this.length) {
                emit = true;
                len = this.length - this.offset;
            }
            // TODO: optimize for case where a copy isn't needed can a slice can
            // be used instead?
            data.copy(this.buffer, this.offset, i, i + len);
            this.offset += len;
            i += len - 1;
            if (emit) {
                var buffer = this.buffer;
                this.reset();
                var message;
                try {
                    message = msgpack.decode(buffer);
                } catch (err) {
                    this.emit("error", err);
                    break;
                }
                this.emit("message", message);
            }
            break;
        }
    }
};
